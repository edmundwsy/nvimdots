{
    "solu": {
        "prefix": "solu",
        "body": [
            "class Solution",
            "{",
            "public:",
            "\t$1 $2($3) {",
            "\t\t$4",
            "\t}",
            "};"
        ],
        "description": "leetcode class Solution template"
    },
    "lc": {
        "prefix": "lc",
        "body": [
            "#include <bits/stdc++.h>",
            "",
            "using namespace std;",
            "",
            "class Solution",
            "{",
            "public:",
            "\t$1 $2($3) {",
            "\t\t$4",
            "\t}",
            "};",
            "",
            "int main(int argc, char *argv[]) {",
            "\tSolution s;",
            "\treturn 0;",
            "}"
        ],
        "description": "leetcode template"
    },
    "rosnodeTemplateSimple": {
        "prefix": "rosNodeSimple",
        "body": [
            "#include <ros/ros.h>\n",
            "int main(int argc, char* argv[])",
            "{",
            "\tros::init(argc, argv, \"${1:/*node_name*/}\");",
            "\tros::NodeHandle nh;",
            "\t${0}",
            "}"
        ],
        "description": "ROS node template"
    },
    "rosClassTemplateSimple": {
        "prefix": "rosClassTemplate",
        "body": [
            "/** @brief",
            " * @class ${1}",
            "*/",
            "class ${1:class_name}",
            "{",
            "public:",
            "\t\t${0}",
            "\t}\n",
            "private:\n",
            "};"
        ],
        "description": "ROS node template"
    },
    "ros::init": {
        "prefix": "rosinit",
        "body": "ros::init(argc, argv, \"${1:/*node_name*/}\");\nros::NodeHandle n;\n$0",
        "description": "ros::init()"
    },
    "ros::Publisher": {
        "prefix": "rosPublisher",
        "body": [
            "ros::Publisher ${1:pub_name};",
            "${1} = nh.advertise<${2: msg_type}>(\"${3:topic_name}\", ${5:10});\n$0"
        ],
        "description": "ros::Publisher"
    },
    "ros::Subscriber": {
        "prefix": "rosSubcriber",
        "body": [
            "ros::Subscriber ${1:/*sub_name*/};",
            "${1} = nh.subscribe<${2:msg_type}>(\"${3:topic_name}\", ${4:10}, ${5:subscribe_callback_name});",
            "$0"
        ],
        "description": "ros::Subscriber"
    },
    "ros::Subscriber callback": {
        "prefix": "rosSubscriberCallback",
        "body": [
            "void ${1:subscribe_callback_name}(const ${2:msg_type} &msg)",
            "{",
            "\t${0}",
            "}"
        ],
        "description": "ros::Subscriber callback"
    },
    "ros::ServiceServer": {
        "prefix": "rosServiceServer",
        "body": [
            "ros::ServiceServer ${1:service_server_object};",
            "${1} = nh.advertiseService(\"${2:service_name}\", ${3:service_callback_func});",
            "$0"
        ],
        "description": "ros::ServiceServer"
    },
    "ros::ServiceServer callback": {
        "prefix": "rosServiceCallback",
        "body": [
            "bool ${1:service_callback_func}(${2:service_type}::Request &req, ${2}::Response &res)",
            "{",
            "\t${0}",
            "\treturn true;",
            "}"
        ],
        "description": "ros::ServiceServer callback"
    },
    "ros::ServiceClient": {
        "prefix": "rosServiceClient",
        "body": [
            "ros::ServiceClient ${1:service_client_object};",
            "${1} = nh.serviceClient<${2:service_type}>(\"${3:service_name}\");",
            "$0"
        ],
        "description": "ros::ServiceClient"
    },
    "ros::ActionClient": {
        "prefix": "rosActionClient",
        "body": [
            "ros::SimpleActionClient<${1:action_type}> ${2:action_client_object}(${3:action_name});",
            "$0"
        ],
        "description": "ros::ActionClient"
    },
    "ros rate while": {
        "prefix": "rosRateWhile",
        "body": [
            "ros::Rate loop_rate(${1:10});",
            "while (ros::ok())",
            "{",
            "\t${0:/* code for loop body */}\n",
            "\tros::spinOnce();",
            "\tloop_rate.sleep();",
            "}"
        ],
        "description": "ros::Rate â€¦ while"
    },
    "ros error": {
        "prefix": "ROSERROR",
        "body": "ROS_ERROR_STREAM(${1});\n$0",
        "description": "ros error"
    },
    "ros info": {
        "prefix": "ROSINFO",
        "body": "ROS_INFO_STREAM(${1});\n$0",
        "description": "ros info"
    },
    "ros debug": {
        "prefix": "ROSDBG",
        "body": "ROS_DEBUG_STREAM(${1});\n$0",
        "description": "ros debug"
    },
    "ros info var": {
        "prefix": "ROSINFOVAR",
        "body": "ROS_INFO_STREAM(\"${2:$1}: \" << $1);\n$0"
    },
    "ros debug var": {
        "prefix": "ROSDBGVAR",
        "body": "ROS_DEBUG_STREAM(\"${1:} = \" << ${2:$1});\n$0"
    },
    "ros assert": {
        "prefix": "ROSASS",
        "body": "ROS_ASSERT(${1:});\n$0"
    },
    "ros get param": {
        "prefix": "rosparam_get",
        "body": "if (!n.getParam(\"$1\", ${1:name}))\n\t{ ROS_ERROR(\"No $1 param\"); }\n$0"
    },
    "rosParam": {
        "prefix": "rosParam",
        "body": [
            "_nh.param<${1:/*data_type*/}>(${2:param_name}, ${3:param_val}, ${4:default_val});",
            "$0"
        ],
        "description": "ros param"
    },
	"for": {
		"prefix": "for",
		"body": [
			"for (${size_t} ${i} = ${1:0}; ${i} < ${2:length}; ${i}++)",
			"{",
			"	$3",
			"}"
		],
		"description": "Code snippet for 'for' loop"
	},
	"forr": {
		"prefix": "forr",
		"body": [
			"for (int ${i} = ${1:length} - 1; ${i} >= ${2:0}; ${i}--)",
			"{",
			"	$3",
			"}"
		],
		"description": "Code snippet for reverse 'for' loop"
	},
	"do": {
		"prefix": "do",
		"body": [
			"do",
			"{",
			"	$1",
			"} while($2);"
		],
		"description": "Code snippet for do...while loop"
	},
	"while": {
		"prefix": "while",
		"body": [
			"while ($1)",
			"{",
			"	$2",
			"}"
		],
		"description": "Code snippet for while loop"
	},
	"foreach": {
		"prefix": "foreach",
		"body": [
			"for(auto ${var} : ${collection_to_loop})",
			"{",
			"	$1",
			"}"
		],
		"description": "Code snippet for range-based for loop (c++11) statement"
	},
	"if": {
		"prefix": "if",
		"body": [
			"if ($1)",
			"{",
			"	$2",
			"}"
		],
		"description": "Code snippet for if statement"
	},
	"else": {
		"prefix": "else",
		"body": [
			"else",
			"{",
			"	$1",
			"}"
		],
		"description": "Code snippet for else statement"
	},
	"else if": {
		"prefix": "else if",
		"body": [
			"else if ($1)",
			"{",
			"	$2",
			"}"
		],
		"description": "Code snippet for else-if statement"
	},
	"enum": {
		"prefix": "enum",
		"body": [
			"enum ${MyEnum}",
			"{",
			"	$1",
			"};"
		],
		"description": "Code snippet for enum"
	},
	"enum class": {
		"prefix": "enum class",
		"body": [
			"enum class ${MyClass} { };"
		],
		"description": "Code snippet for enum class (c++11)"
	},
	"class": {
		"prefix": "class",
		"body": [
			"class ${MyClass}",
			"{",
			"public:",
			"	${MyClass}();",
			"	${MyClass}(${MyClass} &&) = default;",
			"	${MyClass}(const ${MyClass} &) = default;",
			"	${MyClass} &operator=(${MyClass} &&) = default;",
			"	${MyClass} &operator=(const ${MyClass} &) = default;",
			"	~${MyClass}();",
			"",
			"private:",
			"	$1",
			"};",
			"",
			"${MyClass}::${MyClass}()",
			"{",
			"}",
			"",
			"${MyClass}::~${MyClass}()",
			"{",
			"}"
		],
		"description": "Code snippet for class"
	},
	"classi": {
		"prefix": "classi",
		"body": [
			"class ${MyClass}",
			"{",
			"public:",
			"	${MyClass}() = default;",
			"	${MyClass}(${MyClass} &&) = default;",
			"	${MyClass}(const ${MyClass} &) = default;",
			"	${MyClass} &operator=(${MyClass} &&) = default;",
			"	${MyClass} &operator=(const ${MyClass} &) = default;",
			"	~${MyClass}() = default;",
			"",
			"private:",
			"	$1",
			"};"
		],
		"description": "Code snippet for class with inline constructor/destructor"
	},
	"interface": {
		"prefix": "interface",
		"body": [
			"__interface I${Interface}",
			"{",
			"	$1",
			"};"
		],
		"description": "Code snippet for interface (Visual C++)"
	},
	"namespace": {
		"prefix": "namespace",
		"body": [
			"namespace ${MyNamespace}",
			"{",
			"	$1",
			"}"
		],
		"description": "Code snippet for namespace"
	},
	"#ifdef": {
		"prefix": "#ifdef",
		"body": [
			"#ifdef ${DEBUG}",
			"$1",
			"#endif // ${DEBUG}"
		],
		"description": "Code snippet for #ifdef"
	},
	"#ifndef": {
		"prefix": "#ifndef",
		"body": [
			"#ifndef ${1:1}",
			"$2",
			"#endif // !$1"
		],
		"description": "Code snippet for #ifndef"
	},
	"#if": {
		"prefix": "#if",
		"body": [
			"#ifdef ${1:0}",
			"$2",
			"#endif // $1"
		],
		"description": "Code snippet for #if"
	},
	"struct": {
		"prefix": "struct",
		"body": [
			"struct ${MyStruct}",
			"{",
			"	$1",
			"};"
		],
		"description": "Code snippet for struct"
	},
	"switch": {
		"prefix": "switch",
		"body": [
			"switch (${switch_on})",
			"{",
			"default:",
			"	break;$1",
			"}"
		],
		"description": "Code snippet for switch statement"
	},
	"try": {
		"prefix": "try",
		"body": [
			"try",
			"{",
			"	",
			"}",
			"catch (const std::exception&)",
			"{",
			"	$1",
			"}"
		],
		"description": "Code snippet for try catch"
	},
	"union": {
		"prefix": "union",
		"body": [
			"union ${MyUnion}",
			"{",
			"	$1",
			"};"
		],
		"description": "Code snippet for union"
	},
	"cout": {
		"prefix": "cout",
		"body": [
			"std::cout << \"${1:/* message */}\" << std::endl;"
		],
		"description": "Code snippet for printing to std::cout, provided the header is set"
	},
	"#inc": {
		"prefix": "#inc",
		"body": [
			"#include \"$1\""
		],
		"description": "Code snippet for #include \" \""
	},
	"#inc<": {
		"prefix": "#inc<",
		"body": [
			"#include <$1>"
		],
		"description": "Code snippet for #include \" \""
	},
	"#def": {
		"prefix": "#def",
		"body": [
			"#define \"$1\" \"$2\" "
			],
		"description": "Code snippet for #define \" \""
	},
	"main": {
		"prefix": "main",
		"body": [
			"int main(int argc, const char** argv) {",
			"    return 0;",
			"}"
		],
		"description": "Code snippet for main function"
	}
}
